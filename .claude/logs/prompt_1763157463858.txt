You are an expert software engineer. Execute the following requirement immediately. Do not ask questions, do not wait for confirmation. Read the requirement carefully and implement all changes to the codebase as specified.

REQUIREMENT TO EXECUTE NOW:

# Memoize Test Generation & Intent Analysis

## Metadata
- **Category**: performance
- **Effort**: Medium (2/3)
- **Impact**: High (3/3)
- **Scan Type**: perf_optimizer
- **Generated**: 11/14/2025, 9:36:30 PM

## Description
Wrap testTemplates.generate and intentAnalyzer.parse in React.useMemo hooks (or a custom hook) so they recompute only when their input props change. Cache the resulting test structure and intent data to avoid re-generation on every render of the test page.

## Reasoning
Both functions are pure but perform non-trivial computations; memoizing removes unnecessary CPU work during re-renders, improving overall frame rates and perceived speed.

## Context

**Note**: This section provides supporting architectural documentation and is NOT a hard requirement. Use it as guidance to understand existing code structure and maintain consistency.

### Context: NL test

**Description**: ## Overview\
\
The *NL Test* context bundles everything needed to build a natural‑language‑test page in a Next.js application. It supplies a themeable layout, reusable UI primitives, navigation and theme state via React Context, and helper utilities that drive the test logic (prompt generation, intent analysis, and template handling). The goal is to make it simple for developers to plug a test page into the app while keeping styling, theming, and navigation consistent across the entire site.\
\
**Problem solved**:\
- Eliminates duplicated layout and UI code across pages.\
- Centralises theme and navigation state, so components can react to user preferences or navigation changes without prop drilling.\
- Provides a small, well‑typed API for generating prompts, analysing user intent, and rendering test templates, reducing boilerplate for new test pages.\
\
**Who uses it**:\
- Front‑end developers working on Next.js/React projects that need a dynamic, themed UI.\
- Designers who want a consistent card, badge, and loading spinner look‑and‑feel across all test pages.\
- Content writers who can supply intent templates and let the system generate interactive prompts.\
\
## Architecture\
\
The context follows a modular, layered architecture:\
\
1. **Page layer** – `page.tsx` is the Next.js entry point for the NL test. It pulls together layout, header, sidebar, and the main test component.\
2. **Layout layer** – `MainLayout.tsx` composes header, sidebar and main content area, applying global styles and handling responsive behavior.\
3. **UI primitives** – Components such as `Badge`, `LoadingSpinner`, `ThemedCard`, and `ThemeSwitcher` live under `components/ui`. They expose minimal APIs, rely on CSS modules or Tailwind, and are styled according to the current theme.\
4. **Context layer** – `ThemeContext.tsx` and `NavigationContext.tsx` expose global state (current theme, navigation state) and corresponding hooks (`useTheme`, `useNavigation`). They use the React Context API with a reducer pattern for predictable state updates.\
5. **Utility layer** – `lib/` contains pure functions and data: `examplePrompts.ts` defines static prompt templates, `intentAnalyzer.ts` parses user input, `testTemplates.ts` produces renderable test structures, and `theme.ts` holds theme constants and a theme toggle helper.\
6. **Animation helpers** – `animations.ts` exports CSS keyframes or utility classes for subtle entrance/exit effects used across UI components.\
7. **Type layer** – `types.ts` centralises shared TypeScript interfaces (e.g., `Prompt`, `Intent`, `Theme`) to ensure consistency.\
\
**Key patterns**:\
- **React Context + Reducer** for global state.\
- **Component‑First** UI with shared styling.\
- **Pure Utility Functions** for data manipulation.\
- **Type‑Safe Props** via exported interfaces.\
- **Modular CSS/Utility‑First** styling (Tailwind or CSS modules).\
\
## File Structure\
\
```
src/
├─ app/
│  └─ nl-test/
│     └─ page.tsx                     # Next.js page entry point
├─ components/
│  ├─ layout/
│  │  ├─ MainLayout.tsx              # Combines Header, Sidebar, and content
│  │  ├─ Header.tsx                   # Top navigation bar
│  │  └─ Sidebar.tsx                  # Side navigation panel
│  ├─ ui/
│  │  ├─ Badge.tsx                   # Reusable badge component
│  │  ├─ LoadingSpinner.tsx          # Spinner used while loading data
│  │  ├─ ThemedCard.tsx               # Card component that follows theme
│  │  └─ ThemeSwitcher.tsx           # Theme toggle button
│  └─ logo/
│     └─ LogoTitle.tsx                # Site logo + title
├─ contexts/
│  ├─ ThemeContext.tsx               # Theme state & provider
│  └─ NavigationContext.tsx          # Navigation state & provider
├─ lib/
│  ├─ nl-test/
│  │  ├─ examplePrompts.ts           # Static prompt definitions
│  │  ├─ intentAnalyzer.ts           # Parses user input into intents
│  │  └─ testTemplates.ts            # Generates test structure from templates
│  ├─ animations.ts                  # Animation helpers
│  ├─ theme.ts                       # Theme constants & helper functions
│  └─ types.ts                       # Shared TypeScript interfaces
```\
\
**Relationships**:\
- `page.tsx` imports `MainLayout`, which in turn pulls in `Header` and `Sidebar`.\
- UI primitives are consumed by `MainLayout` and any child components.\
- `ThemeContext` provides `theme` and `toggleTheme`, used by `ThemeSwitcher` and `ThemedCard`.\
- `NavigationContext` supplies `currentRoute` and navigation actions used by `Sidebar`.\
- Utility modules (`examplePrompts`, `intentAnalyzer`, `testTemplates`) are imported by the test component rendered within `MainLayout`.\
- `theme.ts` is used by both `ThemeContext` and UI components to access color palettes.\
- `types.ts` is imported across all modules to enforce consistent shape of data structures.\
",
  "fileStructure": "The structure is visualised in the diagram above, showing the top‑level `app/nl-test/page.tsx` as the entry point that composes `MainLayout` (which itself composes `Header`, `Sidebar`, and the test content). UI primitives, contexts, and utility libraries are organised into dedicated folders, with shared types exported from `lib/types.ts`."
}
**Related Files**:
- `src/app/nl-test/page.tsx`
- `src/components/layout/MainLayout.tsx`
- `src/components/ui/Badge.tsx`
- `src/components/ui/LoadingSpinner.tsx`
- `src/components/ui/ThemedCard.tsx`
- `src/contexts/ThemeContext.tsx`
- `src/lib/nl-test/examplePrompts.ts`
- `src/lib/nl-test/intentAnalyzer.ts`
- `src/lib/nl-test/testTemplates.ts`
- `src/components/layout/Header.tsx`
- `src/components/layout/Sidebar.tsx`
- `src/lib/animations.ts`
- `src/lib/theme.ts`
- `src/lib/types.ts`
- `src/components/logo/LogoTitle.tsx`
- `src/components/ui/ThemeSwitcher.tsx`
- `src/contexts/NavigationContext.tsx`

**Post-Implementation**: After completing this requirement, evaluate if the context description or file paths need updates. Use the appropriate API/DB query to update the context if architectural changes were made.

## Recommended Skills

Use Claude Code skills as appropriate for implementation guidance. Check `.claude/skills/` directory for available skills.

## Notes

This requirement was generated from an AI-evaluated project idea. No specific goal is associated with this idea.

IMPORTANT INSTRUCTIONS:
- Analyze the requirement thoroughly
- Identify all files that need to be modified or created
- Implement all changes specified in the requirement
- Follow the implementation steps precisely
- Create/modify files as needed
- Run any tests if specified
- Ensure all changes are complete before finishing

## Context Updates

**CRITICAL**: If this requirement references a specific CONTEXT name or feature area, you MUST update the context documentation using the context update skill.

To update a context:
1. Invoke the `update-context` skill by running: `/skill update-context`
2. The skill will guide you through:
   - Identifying the correct context to update
   - Analyzing the files you've changed
   - Updating the context's file paths to include new/modified files
   - Refreshing the context description to reflect your changes

**When to use the context update skill:**
- The requirement explicitly mentions a context name (e.g., "Update the Goals Management context")
- You've created, modified, or deleted files within a feature area that has an existing context
- Your changes significantly impact the architecture or capabilities of a feature

**Important:** Always invoke the skill AFTER completing your implementation, as it needs to analyze your changes.

## File Structure Guidelines (Next.js/React Projects)

When creating new files in Next.js/React projects, follow this structure:

**Feature-Specific Files** (use `app/features/<feature>` structure):
- `app/features/<feature>/components/` - Feature-specific components and UI sections
- `app/features/<feature>/lib/` - Feature-specific functions, utilities, and logical helpers
- `app/features/<feature>/` - Main wrapper, index, or page file for the feature

**Reusable UI Components** (use `app/components/ui` structure):
- `app/components/ui/` - Shared, reusable UI elements used across multiple features

**Theming and Styling**:
- Before creating new UI components, examine existing components in the project
- Match the color scheme, spacing, and visual patterns of existing components
- Use consistent className patterns (Tailwind CSS classes)
- Follow the app's design language (glassmorphism, gradients, shadows, etc.)
- Pay attention to dark mode support if the app uses it

Examples:
- Feature component: `app/features/tasks/components/TaskCard.tsx`
- Feature helper: `app/features/tasks/lib/taskValidation.ts`
- Reusable UI: `app/components/ui/Button.tsx`

## Test Coverage Preparation

**IMPORTANT**: For all interactive UI components (buttons, inputs, forms, modals, etc.), add `data-testid` attributes to enable automated testing.

**Guidelines**:
- Add `data-testid` to all clickable elements (buttons, links, icons)
- Use descriptive, kebab-case naming: `data-testid="submit-form-btn"`
- Include component context in the ID: `data-testid="goal-delete-btn"`, `data-testid="project-settings-modal"`
- Add to form inputs: `data-testid="email-input"`, `data-testid="password-input"`
- Add to list items for testing selection: `data-testid="task-item-123"`

**Examples**:
```tsx
<button onClick={handleSubmit} data-testid="create-goal-btn">
  Create Goal
</button>

<input
  type="text"
  value={title}
  onChange={handleChange}
  data-testid="goal-title-input"
/>

<div className="modal" data-testid="delete-confirmation-modal">
  ...
</div>
```

## Implementation Logging

**CRITICAL**: After completing the implementation, create a log entry in the SQLite database to track what was implemented.

Database Path: `C:\Users\kazda\kiro\pathfinder\database\goals.db`
Table: `implementation_log`
Project ID: `108b16e3-019b-469c-a329-47138d60a21f`

Execute this SQL command after implementation (replace placeholders with actual values):

```sql
INSERT INTO implementation_log (
  id,
  project_id,
  requirement_name,
  title,
  overview,
  tested,
  created_at
) VALUES (
  '<generate-unique-uuid>',
  '108b16e3-019b-469c-a329-47138d60a21f',
  '<requirement-name>',
  '<short-descriptive-title>',
  '<detailed-overview-of-changes>',
  0,
  datetime('now')
);
```

**Log Entry Guidelines**:
- `id`: Generate a unique UUID (e.g., using `crypto.randomUUID()` or similar)
- `project_id`: The project identifier (use: "108b16e3-019b-469c-a329-47138d60a21f")
- `requirement_name`: Name of the requirement file being executed
- `title`: Short, descriptive title (2-6 words, e.g., "Add User Authentication")
- `overview`: Detailed paragraph describing:
  - What was implemented
  - Key files created or modified
  - Major functionality added
  - Any important patterns or decisions made
- `tested`: Always set to 0 (false) initially
- `created_at`: Use `datetime('now')` for current timestamp

**Example Log Entry**:

```sql
INSERT INTO implementation_log (
  id,
  project_id,
  requirement_name,
  title,
  overview,
  tested,
  created_at
) VALUES (
  '550e8400-e29b-41d4-a716-446655440000',
  'project-abc-123',
  'implement-user-login',
  'User Login System',
  'Implemented complete user authentication system with login form, JWT token management, and session persistence. Created LoginForm.tsx component, authService.ts for API calls, and useAuth hook for state management. Added protected route wrapper and login/logout functionality. Integrated with existing theme using glassmorphism design.',
  0,
  datetime('now')
);
```

**How to Execute the SQL**:
Use the sqlite3 command-line tool or Node.js better-sqlite3 library:

```bash
sqlite3 "C:\Users\kazda\kiro\pathfinder\database\goals.db" "INSERT INTO implementation_log (...) VALUES (...);"
```

Or in Node.js/TypeScript:
```typescript
import Database from 'better-sqlite3';
const db = new Database('C:\Users\kazda\kiro\pathfinder\database\goals.db');
db.prepare(`
  INSERT INTO implementation_log (id, project_id, requirement_name, title, overview, tested, created_at)
  VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
`).run(id, projectId, requirementName, title, overview, 0);
db.close();
```



## Final Checklist

Before finishing:
- [ ] All code changes implemented
- [ ] Test IDs added to interactive components
- [ ] Context documentation updated (if applicable)
- [ ] File structure follows guidelines
- [ ] UI components match existing theme
- [ ] Implementation log entry created in database
- [ ] Tests run successfully (if specified)

Begin implementation now.